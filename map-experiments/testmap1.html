<!--
  Nanryosai 2026
  Version: 0.1.0
  Last Modified: 2026-02-05
  Author: Nanryosai 2026 Project Team
-->
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Interactive Indoor Map with Gemini AI</title>
    <!-- Google Fonts for icons and text -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Noto Sans JP", sans-serif;
        background-color: #f8f9fa; /* æ˜ã‚‹ã„ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯ */
      }

      /* UIã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ã‚¹ã‚¿ã‚¤ãƒ« */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      /* å…±é€šãƒœã‚¿ãƒ³ãƒ»ãƒ‘ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
      .panel {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        pointer-events: auto;
        overflow: hidden;
      }

      /* ãƒ•ãƒ­ã‚¢é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆå³ä¸Šï¼‰ */
      #floor-selector {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        z-index: 10;
      }
      .floor-btn {
        background: white;
        border: none;
        padding: 10px 16px;
        text-align: center;
        cursor: pointer;
        font-weight: 700;
        color: #5f6368;
        border-bottom: 1px solid #dadce0;
        transition: all 0.2s;
        font-size: 14px;
        min-width: 60px;
      }
      .floor-btn:first-child {
        border-radius: 8px 8px 0 0;
      }
      .floor-btn:last-child {
        border-bottom: none;
        border-radius: 0 0 8px 8px;
      }
      .floor-btn:hover {
        background-color: #f1f3f4;
        color: #202124;
      }
      .floor-btn.active {
        color: #1a73e8; /* Google Blue */
        background-color: #e8f0fe;
      }

      /* ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆå³ä¸‹ï¼‰ */
      #zoom-controls {
        position: absolute;
        bottom: 30px;
        right: 20px;
        display: flex;
        flex-direction: column;
        width: 40px;
        border-radius: 4px;
      }
      .zoom-btn {
        width: 40px;
        height: 40px;
        background: white;
        border: none;
        color: #5f6368;
        cursor: pointer;
        border-bottom: 1px solid #dadce0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .zoom-btn:last-child {
        border-bottom: none;
      }
      .zoom-btn:hover {
        color: #202124;
        background-color: #f1f3f4;
      }
      .material-icons {
        font-size: 20px;
      }

      /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ï¼ˆå·¦ä¸‹ï¼‰ */
      #reset-view {
        position: absolute;
        bottom: 30px;
        left: 20px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%; /* ä¸¸ã„ãƒœã‚¿ãƒ³ */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #5f6368;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        transition: background 0.2s;
      }
      #reset-view:hover {
        background-color: #f1f3f4;
        color: #202124;
      }

      /* é¸æŠã•ã‚ŒãŸéƒ¨å±‹ã®æƒ…å ±è¡¨ç¤ºãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
      #info-card {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: white;
        padding: 0; /* paddingã‚’å†…éƒ¨ã‚³ãƒ³ãƒ†ãƒŠã«ç§»å‹• */
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        width: 320px; /* å°‘ã—å¹…åºƒã« */
        text-align: left;
        opacity: 0;
        pointer-events: none;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
      }
      #info-card.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
        pointer-events: auto;
      }
      .info-content {
        padding: 20px 24px;
      }
      #info-title {
        font-size: 20px;
        font-weight: bold;
        color: #202124;
        margin: 0 0 8px 0;
      }
      #info-desc {
        font-size: 13px;
        color: #5f6368;
        margin: 0 0 16px 0;
        line-height: 1.5;
      }
      #close-info {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        color: #999;
        font-size: 18px;
        border: none;
        background: none;
        z-index: 5;
      }

      /* AIæ©Ÿèƒ½ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
      #ai-section {
        border-top: 1px solid #eee;
        padding: 16px 24px;
        background-color: #fafafa;
      }
      .ai-btn {
        background: linear-gradient(135deg, #4285f4, #34a853);
        color: white;
        border: none;
        padding: 10px 16px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        transition: transform 0.1s;
      }
      .ai-btn:hover {
        transform: scale(1.02);
        box-shadow: 0 2px 8px rgba(66, 133, 244, 0.3);
      }
      .ai-btn:active {
        transform: scale(0.98);
      }
      #ai-result {
        margin-top: 12px;
        font-size: 13px;
        color: #333;
        background: white;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
        display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆéè¡¨ç¤º */
        line-height: 1.6;
      }
      #ai-result strong {
        color: #1a73e8;
      }
      .typing-indicator {
        display: inline-block;
        font-style: italic;
        color: #666;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <!-- 3Dãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é ˜åŸŸ -->
    <div id="canvas-container"></div>

    <!-- UIãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
    <div id="ui-layer">
      <!-- ãƒ•ãƒ­ã‚¢é¸æŠ -->
      <div id="floor-selector" class="panel">
        <button class="floor-btn" onclick="changeFloor(2)">2F</button>
        <button class="floor-btn active" onclick="changeFloor(1)">1F</button>
        <button class="floor-btn" onclick="changeFloor(0)">B1</button>
      </div>

      <!-- ã‚ºãƒ¼ãƒ æ“ä½œ -->
      <div id="zoom-controls" class="panel">
        <button class="zoom-btn" onclick="zoomIn()">
          <span class="material-icons">add</span>
        </button>
        <button class="zoom-btn" onclick="zoomOut()">
          <span class="material-icons">remove</span>
        </button>
      </div>

      <!-- ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ -->
      <button
        id="reset-view"
        class="panel"
        onclick="resetCamera()"
        title="ãƒ“ãƒ¥ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ"
      >
        <span class="material-icons">near_me</span>
      </button>

      <!-- æƒ…å ±ã‚«ãƒ¼ãƒ‰ -->
      <div id="info-card" class="panel">
        <button id="close-info" onclick="hideInfo()">
          <span class="material-icons">close</span>
        </button>
        <div class="info-content">
          <h2 id="info-title">ã‚·ãƒ§ãƒƒãƒ—å</h2>
          <p id="info-desc">ãƒ•ãƒ­ã‚¢ã‚¬ã‚¤ãƒ‰æƒ…å ±</p>
        </div>
        <!-- AIæ©Ÿèƒ½ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div id="ai-section">
          <button class="ai-btn" onclick="askAI()">
            <span>âœ¨</span> AIã‚³ãƒ³ã‚·ã‚§ãƒ«ã‚¸ãƒ¥ã«èã
          </button>
          <div id="ai-result"></div>
        </div>
      </div>
    </div>

    <!-- Three.js ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls ã®èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      // --- Gemini API Configuration ---
      const apiKey = ""; // APIã‚­ãƒ¼ã¯å®Ÿè¡Œç’°å¢ƒã§è‡ªå‹•çš„ã«æŒ¿å…¥ã•ã‚Œã¾ã™

      // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
      let scene, camera, renderer, controls;
      let raycaster, mouse;
      let currentFloorGroup;
      const floors = {};
      let hoveredObject = null;
      let selectedObject = null;

      // ç¾åœ¨é¸æŠä¸­ã®ã‚·ãƒ§ãƒƒãƒ—æƒ…å ±
      let currentShopData = { name: "", type: "" };

      // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ (Google Maps Indoor style)
      const COLORS = {
        background: 0xf8f9fa, // èƒŒæ™¯
        floor: 0xebe9e4, // é€šè·¯ï¼ˆãƒ™ãƒ¼ã‚¸ãƒ¥ï¼‰
        wall: 0xffffff, // åº—èˆ—ï¼ˆç™½ï¼‰
        wallHover: 0xf1f3f4, // ãƒ›ãƒãƒ¼æ™‚ã®è–„ã„ã‚°ãƒ¬ãƒ¼
        wallSelected: 0xe8f0fe, // é¸æŠæ™‚ã®è–„ã„é’
        stroke: 0xdadce0, // è¼ªéƒ­ç·šï¼ˆè–„ã„ã‚°ãƒ¬ãƒ¼ï¼‰
        strokeSelected: 0x4285f4, // é¸æŠæ™‚ã®è¼ªéƒ­ç·šï¼ˆé’ï¼‰
        text: 0x3c4043, // ãƒ†ã‚­ã‚¹ãƒˆè‰²
      };

      init();
      animate();

      function init() {
        const container = document.getElementById("canvas-container");

        // 1. ã‚·ãƒ¼ãƒ³
        scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.background);

        // 2. ã‚«ãƒ¡ãƒ© (OrthographicCamera)
        const aspect = window.innerWidth / window.innerHeight;
        const d = 50;
        camera = new THREE.OrthographicCamera(
          -d * aspect,
          d * aspect,
          d,
          -d,
          1,
          1000,
        );

        // ã‚¢ã‚¤ã‚½ãƒ¡ãƒˆãƒªãƒƒã‚¯è¦–ç‚¹
        camera.position.set(60, 60, 60);
        camera.lookAt(scene.position);

        // 3. ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // é«˜è§£åƒåº¦å¯¾å¿œ
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // 4. ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.screenSpacePanning = true;
        controls.minZoom = 0.5;
        controls.maxZoom = 3;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.rotateSpeed = 0.6;

        // 5. ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
        // ç’°å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
        scene.add(ambientLight);

        // å¹³è¡Œå…‰æº (å½±ç”¨)
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(40, 80, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0001;
        // å½±ã®ç¯„å›²è¨­å®š
        const shadowSize = 60;
        dirLight.shadow.camera.left = -shadowSize;
        dirLight.shadow.camera.right = shadowSize;
        dirLight.shadow.camera.top = shadowSize;
        dirLight.shadow.camera.bottom = -shadowSize;
        scene.add(dirLight);

        // 6. ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // 7. ãƒãƒƒãƒ—ç”Ÿæˆ
        createFloors();

        // 8. ã‚¤ãƒ™ãƒ³ãƒˆ
        window.addEventListener("resize", onWindowResize);
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("click", onMouseClick);
      }

      // --- ãƒãƒƒãƒ—ç”Ÿæˆ ---

      function createFloors() {
        // 1éš
        floors[1] = new THREE.Group();
        createBaseFloor(floors[1]);

        // åº—èˆ—é…ç½®: x, z, w, d, name, type
        // ãƒ¡ã‚¤ãƒ³é€šè·¯ã‚’æŒŸã‚“ã§é…ç½®ã™ã‚‹ã‚ˆã†ãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

        // å·¦ä¸Šã‚¨ãƒªã‚¢
        createShop(floors[1], -20, -15, 14, 16, "ã‚«ãƒ•ã‚§", "cafe");
        createShop(floors[1], -20, 5, 14, 14, "Book Store", "shop");
        createShop(floors[1], -20, 22, 14, 10, "ATM", "service");

        // å³ä¸Šã‚¨ãƒªã‚¢ï¼ˆãƒˆã‚¤ãƒ¬ãªã©ï¼‰
        createShop(floors[1], 15, -20, 10, 8, "ãƒˆã‚¤ãƒ¬", "restroom");
        createShop(floors[1], 25, -12, 8, 8, "å–«ç…™æ‰€", "smoking");

        // ä¸­å¤®ãƒ»å³ä¸‹ï¼ˆå¤§å‹åº—èˆ—ï¼‰
        const attMain = createShop(floors[1], 15, 10, 24, 18, "AT&T", "main");

        // ã‚¤ãƒ³ãƒ•ã‚©ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        createShop(floors[1], 0, -20, 8, 6, "i", "info");

        scene.add(floors[1]);
        currentFloorGroup = floors[1];

        // 2éš
        floors[2] = new THREE.Group();
        createBaseFloor(floors[2]);
        createShop(floors[2], -15, -15, 20, 20, "Restaurant", "cafe");
        createShop(floors[2], 15, 15, 20, 20, "Cinema", "main");
        createShop(floors[2], 0, 0, 8, 8, "å¹æŠœ", "void");
        floors[2].visible = false;
        scene.add(floors[2]);

        // åœ°ä¸‹
        floors[0] = new THREE.Group();
        createBaseFloor(floors[0]);
        createShop(floors[0], 0, 0, 40, 30, "Super Market", "main");
        floors[0].visible = false;
        scene.add(floors[0]);
      }

      function createBaseFloor(group) {
        // é€šè·¯ï¼ˆãƒ•ãƒ­ã‚¢å…¨ä½“ï¼‰
        const geometry = new THREE.PlaneGeometry(120, 120);
        const material = new THREE.MeshLambertMaterial({ color: COLORS.floor });
        const plane = new THREE.Mesh(geometry, material);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -0.1;
        plane.receiveShadow = true;
        group.add(plane);

        // ãƒ•ãƒ­ã‚¢ã®å¢ƒç•Œç·šï¼ˆè£…é£¾ï¼‰
        const edges = new THREE.EdgesGeometry(
          new THREE.BoxGeometry(120, 0.2, 120),
        );
        const line = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({ color: 0xdadada }),
        );
        line.position.y = -0.15;
        group.add(line);
      }

      function createShop(group, x, z, w, d, name, type) {
        const h = type === "void" ? 0.2 : 5; // å¹æŠœã¯ä½ã
        const y = h / 2;

        // ã‚¸ã‚ªãƒ¡ãƒˆãƒª
        const geometry = new THREE.BoxGeometry(w, h, d);

        // ãƒ†ã‚¯ã‚¹ãƒãƒ£
        const texture = type === "void" ? null : createLabelTexture(name, type);

        // ãƒãƒ†ãƒªã‚¢ãƒ«
        const wallMat = new THREE.MeshLambertMaterial({ color: COLORS.wall });
        const topMat =
          type === "void"
            ? new THREE.MeshLambertMaterial({ color: 0x333333 })
            : new THREE.MeshLambertMaterial({ map: texture, color: 0xffffff });

        const materials = [
          wallMat,
          wallMat, // å³ãƒ»å·¦
          topMat, // ä¸Š
          wallMat, // ä¸‹
          wallMat,
          wallMat, // å‰ãƒ»å¾Œ
        ];

        const mesh = new THREE.Mesh(geometry, materials);
        mesh.position.set(x, y, z);

        if (type !== "void") {
          mesh.castShadow = true;
          mesh.receiveShadow = true;
        }

        // è¼ªéƒ­ç·š (Edges)
        const edgesGeometry = new THREE.EdgesGeometry(geometry);
        const edgesMaterial = new THREE.LineBasicMaterial({
          color: COLORS.stroke,
          linewidth: 1,
        });
        const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        mesh.add(edges);

        // ãƒ‡ãƒ¼ã‚¿ä¿æŒ
        mesh.userData = {
          isShop: true,
          name: name,
          type: type,
          edges: edges,
        };

        // ç‰¹åˆ¥ãªè‰²ä»˜ã‘
        if (type === "restroom" || type === "smoking") {
          mesh.userData.specialColor = 0xf5f5f5;
          wallMat.color.setHex(0xf5f5f5);
        }

        group.add(mesh);
        return mesh;
      }

      function createLabelTexture(text, type) {
        const canvas = document.createElement("canvas");
        const w = 512;
        const h = 512;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#FFFFFF";
        if (type === "restroom") ctx.fillStyle = "#f1f3f4";
        if (type === "info") ctx.fillStyle = "#e8f0fe";
        ctx.fillRect(0, 0, w, h);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#3C4043";

        if (type === "restroom") {
          ctx.font = '150px "Material Icons"';
          ctx.fillText("WC", w / 2, h / 2);
        } else if (type === "info") {
          ctx.font = 'bold 200px "Noto Sans JP"';
          ctx.fillStyle = "#1a73e8";
          ctx.fillText("?", w / 2, h / 2);
        } else if (type === "main") {
          ctx.fillStyle = "#1a73e8";
          ctx.beginPath();
          ctx.arc(w / 2, h / 2 - 60, 40, 0, Math.PI * 2);
          ctx.fill();

          ctx.font = 'bold 60px "Noto Sans JP"';
          ctx.fillStyle = "#3C4043";
          ctx.fillText(text, w / 2, h / 2 + 60);
        } else {
          ctx.font = 'bold 50px "Noto Sans JP"';
          if (text.length > 8) {
            ctx.fillText(text.substring(0, 8), w / 2, h / 2 - 30);
            ctx.fillText(text.substring(8), w / 2, h / 2 + 30);
          } else {
            ctx.fillText(text, w / 2, h / 2);
          }
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        return texture;
      }

      // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© ---

      function onWindowResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const d = 50;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(
          currentFloorGroup.children,
          false,
        );

        if (intersects.length > 0) {
          const object = intersects[0].object;

          if (object.userData.isShop && object.userData.type !== "void") {
            document.body.style.cursor = "pointer";

            if (hoveredObject !== object) {
              if (hoveredObject && hoveredObject !== selectedObject) {
                setObjectState(hoveredObject, "normal");
              }
              hoveredObject = object;
              if (object !== selectedObject) {
                setObjectState(object, "hover");
              }
            }
            return;
          }
        }

        document.body.style.cursor = "default";
        if (hoveredObject) {
          if (hoveredObject !== selectedObject) {
            setObjectState(hoveredObject, "normal");
          }
          hoveredObject = null;
        }
      }

      function onMouseClick(event) {
        if (hoveredObject) {
          selectObject(hoveredObject);
        } else {
          if (selectedObject) {
            setObjectState(selectedObject, "normal");
            selectedObject = null;
            hideInfo();
          }
        }
      }

      // --- çŠ¶æ…‹ç®¡ç†ãƒ»ãƒ˜ãƒ«ãƒ‘ãƒ¼ ---

      function setObjectState(mesh, state) {
        const materials = mesh.material;
        const edges = mesh.userData.edges;
        const isSpecial = mesh.userData.specialColor;

        let wallColorHex = isSpecial || COLORS.wall;
        let edgeColorHex = COLORS.stroke;

        if (state === "hover") {
          wallColorHex = COLORS.wallHover;
        } else if (state === "selected") {
          wallColorHex = COLORS.wallSelected;
          edgeColorHex = COLORS.strokeSelected;
        }

        materials.forEach((m) => {
          if (!m.map) m.color.setHex(wallColorHex);
        });

        if (edges) {
          edges.material.color.setHex(edgeColorHex);
          edges.material.opacity = state === "selected" ? 1.0 : 0.5;
          edges.material.transparent = true;
          edges.visible = true;
        }
      }

      function selectObject(mesh) {
        if (selectedObject && selectedObject !== mesh) {
          setObjectState(selectedObject, "normal");
        }
        selectedObject = mesh;
        setObjectState(mesh, "selected");

        showInfo(mesh.userData.name, mesh.userData.type);
      }

      // --- UIãƒ­ã‚¸ãƒƒã‚¯ ---

      function changeFloor(floorNum) {
        Object.values(floors).forEach((g) => (g.visible = false));
        floors[floorNum].visible = true;
        currentFloorGroup = floors[floorNum];

        const btns = document.querySelectorAll(".floor-btn");
        const map = { 2: 0, 1: 1, 0: 2 };
        btns.forEach((btn, idx) => {
          btn.classList.toggle("active", idx === map[floorNum]);
        });

        if (selectedObject) {
          setObjectState(selectedObject, "normal");
          selectedObject = null;
        }
        hideInfo();
      }

      function showInfo(name, type) {
        // ç¾åœ¨ã®ã‚·ãƒ§ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        currentShopData = { name: name, type: type };

        const card = document.getElementById("info-card");
        const title = document.getElementById("info-title");
        const desc = document.getElementById("info-desc");
        const aiResult = document.getElementById("ai-result");

        title.innerText = name;

        let description = "1éšãƒ»ä¸­å¤®ã‚¨ãƒªã‚¢";
        if (type === "cafe")
          description = "ã‚«ãƒ•ã‚§ãƒ»è»½é£Ÿ / å–¶æ¥­æ™‚é–“ 10:00 - 20:00";
        if (type === "restroom") description = "å¤šç›®çš„ãƒˆã‚¤ãƒ¬ãƒ»æˆä¹³å®¤ã‚ã‚Š";
        if (type === "main")
          description = "ãƒ¡ã‚¤ãƒ³ãƒ†ãƒŠãƒ³ãƒˆ / å–¶æ¥­æ™‚é–“ 10:00 - 21:00";

        desc.innerText = description;

        // AIçµæœã‚’ãƒªã‚»ãƒƒãƒˆ
        aiResult.style.display = "none";
        aiResult.innerHTML = "";

        card.classList.add("visible");
      }

      function hideInfo() {
        const card = document.getElementById("info-card");
        card.classList.remove("visible");

        if (selectedObject) {
          setObjectState(selectedObject, "normal");
          selectedObject = null;
        }
      }

      // --- Gemini AI Feature ---

      async function askAI() {
        const resultDiv = document.getElementById("ai-result");
        resultDiv.style.display = "block";
        resultDiv.innerHTML =
          '<span class="typing-indicator">âœ¨ AIãŒæƒ…å ±ã‚’ç”Ÿæˆä¸­...</span>';

        const prompt = `ã‚ãªãŸã¯ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ«ã®è¦ªåˆ‡ãªã‚³ãƒ³ã‚·ã‚§ãƒ«ã‚¸ãƒ¥ã§ã™ã€‚
ãŠå®¢æ§˜ãŒã€Œ${currentShopData.name}ã€ï¼ˆã‚«ãƒ†ã‚´ãƒª: ${currentShopData.type}ï¼‰ã¨ã„ã†æ–½è¨­ã‚’é¸æŠã—ã¾ã—ãŸã€‚
ã“ã®æ–½è¨­ã«ã¤ã„ã¦ã€é­…åŠ›çš„ã§ç°¡æ½”ãªç´¹ä»‹æ–‡ï¼ˆ80æ–‡å­—ä»¥å†…ï¼‰ã¨ã€ã“ã“ã§ã®ã€ŒãŠã™ã™ã‚ã®éã”ã—æ–¹ã€ï¼ˆ50æ–‡å­—ä»¥å†…ï¼‰ã‚’1ã¤ææ¡ˆã—ã¦ãã ã•ã„ã€‚
å‡ºåŠ›å½¢å¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãã ã•ã„ï¼š
ã€ç´¹ä»‹ã€‘(ã“ã“ã«ç´¹ä»‹æ–‡)
ã€ãŠã™ã™ã‚ã€‘(ã“ã“ã«ãŠã™ã™ã‚)
èªèª¿ã¯ä¸å¯§ã§æ˜ã‚‹ã„æ—¥æœ¬èªã§ãŠé¡˜ã„ã—ã¾ã™ã€‚`;

        try {
          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                contents: [
                  {
                    parts: [
                      {
                        text: prompt,
                      },
                    ],
                  },
                ],
              }),
            },
          );

          const data = await response.json();

          if (data.error) {
            throw new Error(data.error.message);
          }

          const rawText = data.candidates[0].content.parts[0].text;

          // ç°¡å˜ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ•´å½¢
          const formattedText = rawText
            .replace("ã€ç´¹ä»‹ã€‘", "<strong>ç´¹ä»‹:</strong> ")
            .replace("ã€ãŠã™ã™ã‚ã€‘", "<br><strong>ğŸ’¡ ãŠã™ã™ã‚:</strong> ");

          resultDiv.innerHTML = formattedText;
        } catch (error) {
          console.error("Gemini API Error:", error);
          resultDiv.innerHTML =
            '<span style="color:red;">ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚ç¾åœ¨AIã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚</span>';
        }
      }

      // --- Camera Controls ---

      function zoomIn() {
        camera.zoom = Math.min(camera.zoom + 0.4, 4);
        camera.updateProjectionMatrix();
      }

      function zoomOut() {
        camera.zoom = Math.max(camera.zoom - 0.4, 0.5);
        camera.updateProjectionMatrix();
      }

      function resetCamera() {
        controls.reset();
        camera.zoom = 1;
        camera.position.set(60, 60, 60);
        camera.lookAt(scene.position);
        camera.updateProjectionMatrix();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
